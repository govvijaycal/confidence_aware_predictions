from __future__ import annotations
from dataclasses import dataclass, field
from typing import List
import numpy as np
import pickle
import os
import sys
from scipy.spatial.distance import directed_hausdorff

scriptdir = os.path.abspath(__file__).split('evaluation')[0] + 'carla/'
sys.path.append(scriptdir)
from utils.frenet_trajectory_handler import FrenetTrajectoryHandler

"""
Main class to store a closed loop trajectory for analysis.
"""
@dataclass(frozen=True)
class ClosedLoopTrajectory:
	# Arguments required from constructor.
	state_trajectory : np.ndarray  # N x 5, [time (s), x (m), y(m), yaw(rad), v(m/s)]
	input_trajectory : np.ndarray  # N x 2, [longitudinal_accel (m/s^2), steering_angle (rad)]
	feasibility      : np.ndarray  # N, if the corresponding problem was feasible
	solve_times      : np.ndarray  # N, solve_time of corresponding problem (s)
	l_f              : float       # length from center of gravity to front axle (m)
	l_r              : float       # length from center of gravity to rear axle (m)

	# Automatically generated by __post_init__, not given as argument to constructor.
	N         : int        = field(init=False, repr=False) # horizon of trajectory
	lat_accel : np.ndarray = field(init=False, repr=False) # N x 1, lateral acceleration
	jerk      : np.ndarray = field(init=False, repr=False) # (N-1) x 2, (long_jerk, lat_jerk)
	curvature : np.ndarray = field(init=False, repr=False) # N x 1, curvature

	def __post_init__(self):
		# Sanity check about constructor arguments..
		if self.state_trajectory.shape[0] != \
		   self.input_trajectory.shape[0] != \
		   self.feasibility.size      != \
		   self.solve_times.size:
			raise ValueError("Fields state_trajectory, input_trajectory, feasibility, and solve_times have varying number of timestamps")

		if self.state_trajectory.shape[1] != 5:
			raise ValueError(f"State trajectory should have vector entries of size 5, not {self.state_trajectory.shape[1]}")
		if self.input_trajectory.shape[1] != 2:
			raise ValueError(f"Input trajectory should have vector entries of size 2, not {self.input_trajectory.shape[1]}")

		if len(self.feasibility.shape) > 1 or len(self.solve_times.shape) > 1:
			raise ValueError("Feasibility and solve times should be vectors, but have shapes: "
				              f"{self.feasibility.shape} and {self.solve_times.shape}")

		if self.l_f <= 0 or self.l_r <= 0:
			raise ValueError(f"Expected positive l_f : {self.l_f} and l_r : {self.l_r}")

		# Do the computation of associated states / metadata given constructor arguments.
		ts = self.state_trajectory[:,0]
		xs = self.state_trajectory[:,1]
		ys = self.state_trajectory[:,2]
		ps = self.state_trajectory[:,3]
		vs = self.state_trajectory[:,4]

		accs    = self.input_trajectory[:,0]
		deltas  = self.input_trajectory[:,1]

		dts = np.diff( ts )
		if np.any( np.isclose(dts, 0.) ) or np.any( dts < 0 ):
			raise ValueError(f"Expected only positive dts but encountered zero/negative dt: {np.amin(dts)}")

		object.__setattr__(self, "N", self.state_trajectory.shape[0])

		beta = np.arctan( self.l_r / (self.l_f + self.l_r) * np.tan(deltas) )

		object.__setattr__(self, "curvature", np.sin(beta) / self.l_r)

		object.__setattr__(self, "lat_accel", self.curvature * np.square(vs))

		long_jerk = np.diff(accs) / dts
		lat_jerk  = np.diff(self.curvature) / dts * np.square(vs[:-1]) + \
		                2 * self.curvature[:-1] * accs[:-1] * vs[:-1]
		object.__setattr__(self, "jerk", np.column_stack((long_jerk, lat_jerk)))

	def __str__(self):
		return f"Trajectory with {self.N} timestamps."

"""
Metrics Computation
"""
def time_to_complete(cl_traj : ClosedLoopTrajectory) -> float:
	start_time = cl_traj.state_trajectory[ 0,0]
	end_time   = cl_traj.state_trajectory[-1,0]
	return end_time - start_time

def max_lateral_acceleration(cl_traj : ClosedLoopTrajectory) -> float:
	return np.amax( np.abs(cl_traj.lat_accel) )

def max_longitudinal_jerk(cl_traj : ClosedLoopTrajectory) -> float:
	return np.amax( np.abs(cl_traj.jerk[:,0]) )

def max_lateral_jerk(cl_traj : ClosedLoopTrajectory) -> float:
	return np.amax( np.abs(cl_traj.jerk[:,1]) )

def avg_longitudinal_jerk(cl_traj : ClosedLoopTrajectory) -> float:
	return np.mean( np.abs(cl_traj.jerk[:,0]) )

def avg_lateral_jerk(cl_traj : ClosedLoopTrajectory) -> float:
	return np.mean( np.abs(cl_traj.jerk[:,1]) )

def feasibility_percent(cl_traj : ClosedLoopTrajectory) -> float:
	feasible_bool = cl_traj.feasibility.astype(np.bool)
	return np.sum(feasible_bool) / len(feasible_bool)

def get_average_solve_time(cl_traj : ClosedLoopTrajectory) -> float:
	return np.nanmean( cl_traj.solve_times ) # ignore infeasible cases

def get_distances_to_TV(cl_traj_ego : ClosedLoopTrajectory,
	                    cl_traj_tvs : List[ClosedLoopTrajectory]) -> List[np.ndarray]:
	dist_trajs_TV = [] # each index is a different target vehicle, array {t, d(EV, TV_i)}

	def interp_traj(t_range, state_traj):
		x_interp = np.interp(t_range, state_traj[:,0], state_traj[:, 1])
		y_interp = np.interp(t_range, state_traj[:,0], state_traj[:, 2])
		return np.column_stack((x_interp, y_interp))

	for cl_traj_tv in cl_traj_tvs:
		# Get the common time interval where the EV and TV are both moving.
		t_min = max( np.min(cl_traj_tv.state_trajectory[:,0]),
			         np.min(cl_traj_ego.state_trajectory[:,0]) )
		t_max = min( np.max(cl_traj_tv.state_trajectory[:,0]),
			         np.max(cl_traj_ego.state_trajectory[:,0]) )
		dt = np.mean( np.diff(cl_traj_ego.state_trajectory[:,0]) )
		t_range = np.arange(t_min, t_max + 0.5 * dt, dt)

		positions_ego = interp_traj(t_range, cl_traj_ego.state_trajectory)
		positions_tv  = interp_traj(t_range, cl_traj_tv.state_trajectory)

		dists_ego_tv  = np.linalg.norm(positions_ego - positions_tv, axis=-1)

		dist_traj = np.column_stack((t_range, dists_ego_tv))
		dist_trajs_TV.append(dist_traj)

	return dist_trajs_TV

def get_min_dist_per_TV(cl_traj_ego : ClosedLoopTrajectory,
	                    cl_trajs_tv : List[ClosedLoopTrajectory]) -> List[float]:
	dist_trajs_TV = get_distances_to_TV(cl_traj_ego, cl_trajs_tv)
	dmin_per_TV   = [np.amin(dist_traj[:,1]) for dist_traj in dist_trajs_TV]
	return dmin_per_TV

"""
Main class to hold scenario data and compute metrics.
"""
@dataclass(frozen=True)
class ScenarioResult:
	# Ego vehicle closed-loop trajectory:
	ego_closed_loop_trajectory  : ClosedLoopTrajectory

	# Target vehicle fields:
	tv_closed_loop_trajectories : List[ClosedLoopTrajectory]

	# Metric computation
	def compute_metrics(self) -> dict:
		metric_dict = {}
		metric_dict["completion_time"]          = time_to_complete(self.ego_closed_loop_trajectory)
		metric_dict["max_lateral_acceleration"] = max_lateral_acceleration(self.ego_closed_loop_trajectory)
		metric_dict["max_longitudinal_jerk"]    = max_longitudinal_jerk(self.ego_closed_loop_trajectory)
		metric_dict["max_lateral_jerk"]         = max_lateral_jerk(self.ego_closed_loop_trajectory)
		metric_dict["avg_longitudinal_jerk"]    = avg_longitudinal_jerk(self.ego_closed_loop_trajectory)
		metric_dict["avg_lateral_jerk"]         = avg_lateral_jerk(self.ego_closed_loop_trajectory)
		metric_dict["feasibility_percent"]      = feasibility_percent(self.ego_closed_loop_trajectory)
		metric_dict["average_solve_time"]       = get_average_solve_time(self.ego_closed_loop_trajectory)
		metric_dict["dmins_per_TV"]             = get_min_dist_per_TV(self.ego_closed_loop_trajectory, \
			                                                          self.tv_closed_loop_trajectories)
		return metric_dict

	def get_distances_to_TV(self) -> List[np.ndarray]:
		return get_distances_to_TV(self.ego_closed_loop_trajectory, \
			                       self.tv_closed_loop_trajectories)

	def compute_ego_hausdorff_dist(self, sc_other : ScenarioResult) -> float:
		xy_self  = self.ego_closed_loop_trajectory.state_trajectory[:, 1:3]
		xy_other = sc_other.ego_closed_loop_trajectory.state_trajectory[:, 1:3]
		d_H = max(directed_hausdorff(xy_self, xy_other)[0],
			      directed_hausdorff(xy_other, xy_self)[0])
		return d_H

	def compute_ego_frenet_projection(self, sc_frenet_ref : ScenarioResult) -> np.ndarray:
		t_self    = self.ego_closed_loop_trajectory.state_trajectory[:, 0]
		xy_self   = self.ego_closed_loop_trajectory.state_trajectory[:, 1:3]
		yaw_self  = self.ego_closed_loop_trajectory.state_trajectory[:, 3]

		xy_other  = sc_frenet_ref.ego_closed_loop_trajectory.state_trajectory[:, 1:3]
		yaw_other   = sc_frenet_ref.ego_closed_loop_trajectory.state_trajectory[:, 3]
		diff_xy   = np.diff(xy_other, axis=0)
		s_other   = np.cumsum( np.sqrt( np.sum( np.square(diff_xy), axis=1) ) )
		s_other   = np.insert( s_other, 0, [0.0] )

		frenet_ref = FrenetTrajectoryHandler(s_other, xy_other, yaw_other)

		s_self  = []
		ey_self = []
		epsi_self = []

		for (xy, psi) in zip(xy_self, yaw_self):
			x, y = xy
			s, ey, epsi = frenet_ref.convert_global_to_frenet_frame(x,y,psi)

			s_self.append(s)
			ey_self.append(ey)
			epsi_self.append(epsi)

		return t_self, np.array(s_self), np.array(ey_self), np.array(epsi_self)

def load_scenario_result(pkl_path):
    scenario_dict = pickle.load(open(pkl_path, "rb"))

    ego_entry   = [v for (k, v) in scenario_dict.items() if "ego" in k]
    tv_entries  = [v for (k, v) in scenario_dict.items() if "ego" not in k]
    assert len(ego_entry) == 1
    assert len(ego_entry) + len(tv_entries)  == len(scenario_dict.keys())

    sc = ScenarioResult( ego_closed_loop_trajectory = ClosedLoopTrajectory(**ego_entry[0]),
                         tv_closed_loop_trajectories = [ClosedLoopTrajectory(**v) for v in tv_entries])
    return sc